/////////////////////////////////////////////////////////////////////////////////////
//
//   LucED - The Lucid Editor
//
//   Copyright (C) 2005-2010 Oliver Schmidt, oliver at luced dot de
//
//   This program is free software; you can redistribute it and/or modify it
//   under the terms of the GNU General Public License Version 2 as published
//   by the Free Software Foundation in June 1991.
//
//   This program is distributed in the hope that it will be useful, but WITHOUT
//   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
//   more details.
//
//   You should have received a copy of the GNU General Public License along with 
//   this program; if not, write to the Free Software Foundation, Inc., 
//   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
/////////////////////////////////////////////////////////////////////////////////////

#include "ConfigData.hpp"
#include "LuaIterator.hpp"
#include "ConfigException.hpp"

using namespace LucED;

@ local functions  = require("functions")
@ local cap        = functions.capitalize
@
@ local configDef     = require("ConfigDefinition")
@ local defaultConfig = dofile(".luced/config.lua")
@ 
@
@ local converterMethods =
@ {
@   ["bool"]   = "toBoolean",
@   ["String"] = "toString",
@   ["int"]    = "toInt",
@   ["long"]   = "toLong",
@   ["double"] = "toNumber",
@ }
@
@ local function path(p1, p2)
@   return (#p1 > 0 and #p2 > 0 and p2:sub(1,1) ~= "[" and p1.."/"..p2) or (p1..p2)
@ end

/*
void ConfigData::readConfig(LuaVar luaData0)
{
        LuaAccess luaAccess = luaData0.getLuaAccess();
@ local function elementCode(c, classPath, luaConfigPath, counter)
@   if c.type == "map" then
@       assert(c.entries and #c.entries > 0, "no entries in map '"..(c.name or "???").."'")
@       for _, e in ipairs(c.entries) do
@           if e.type == "map" or e.type == "list" then
@               local class = classPath..cap(e.name)
        {
            LuaVar luaData@(counter) = luaData@(counter - 1)["@(e.name)"];
            //ptr@(counter - 1)->@(e.name) = OwningPtr<@(class)>(new @(class)());
            RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(e.name);
@           emluaAddIndent(4)
@           elementCode(e, class.."::", path(luaConfigPath, e.name), counter + 1)
@           emluaAddIndent(-4)
        }
@           else
        {
            LuaVar luaData@(counter) = luaData@(counter - 1)["@(e.name)"];
            if (luaData@(counter).isValid()) {
                ptr@(counter - 1)->@(e.name) = luaData@(counter).@(converterMethods[e.type])();
@           if not e.default then            
            } else {
                throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@           end
            }
        }
@           end
@       end
@   elseif c.type == "list" then
        if (luaData@(counter -1).isValid())
        {
            if (!luaData@(counter -1).isTable()) {
                throw ConfigException(String() << "Error: @(luaConfigPath) must be table, but is "
                                               << luaData@(counter -1).getTypeName());
            }
            for (LuaIterator i@(counter)(luaAccess, 0); 
                             i@(counter).in(luaData@(counter -1)); 
                             ++i@(counter))
@       local e = c.member
@       if e.type == "map" or e.type == "list" or e.type == "alternative" then
@           local class = classPath..cap(e.name)                         
            {
                LuaVar luaData@(counter) = i@(counter).value();
                ptr@(counter - 1)->@(c.name).append(OwningPtr<@(class)>(new @(class)()));
                RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(c.name)[i@(counter)];
@           emluaAddIndent(2*4)
@           elementCode(e, class.."::", 
@                          path(luaConfigPath,    (c.type ~= "list" and e.name) 
@                                              or ('[" << (i'..counter..' + 1) << "]')), 
@                          counter + 1)
@           emluaAddIndent(-2*4)
            }
@       else
            {
                LuaVar luaData@(counter) = i@(counter).value();
                if (luaData@(counter).isValid()) {
                    ptr@(counter - 1)->@(c.name).append(luaData@(counter).@(converterMethods[e.type])());
@           if not e.default then            
                } else {
                    throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@           end
                }
            }
@       end
        }
@   elseif c.type == "alternative" then
        if (luaData@(counter -1).isValid())
        {
            if (!luaData@(counter -1).isTable()) {
                throw ConfigException(String() << "Error: @(luaConfigPath) must be table, but is "
                                               << luaData@(counter -1).getTypeName());
            }
@       assert(c.alternatives and #c.alternatives > 0, "no entries in alternatives '"..(c.name or "???").."'")
            do
            {
                LuaVar luaData@(counter)(luaAccess);
@       for i, a in ipairs(c.alternatives) do
@           assert(a.type == "map", "alternative "..a.name.." must be of type 'map'")
@           local firstEntry = assert(a.entries[1], "alternative "..a.name.." must have entries")
                luaData@(counter) = luaData@(counter - 1)["@(firstEntry.name)"];
                if (luaData@(counter).isValid())
                {
@           local class = classPath..cap(a.name)
                    luaData@(counter) = luaData@(counter - 1);
                    ptr@(counter - 1)->@(a.name) = OwningPtr<@(class)>(new @(class)());
                    RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(a.name);
@               emluaAddIndent(3*4)
@               elementCode(a, class.."::", path(luaConfigPath, a.name), counter + 1)
@               emluaAddIndent(-3*4)
                    break;
                }
@       end
            } while (false);
        }
@   end
@ end
        RawPtr<ConfigData> ptr0 = this;
@ elementCode(configDef, "", "", 1)
}
*/
@
@
@
@
@ local function classMethods(c, classPath, defaultValues, defaultIndex, luaConfigPath)
@   local constructorMembers = {} 
@   local elements = {}
@   local class
@   if c.type == "map" then
@       class = cap(c.name)
@       elements = c.entries
@
@       for i, e in ipairs(c.entries) do
@           if    e.type == "bool" 
@              or e.type == "int" 
@              or e.type == "long" 
@              or e.type == "double" 
@              or e.type == "String" 
@              or e.type == "map" 
@              or e.type == "list" 
@              or e.type == "alternative" 
@              or e.default 
@           then
@               constructorMembers[#constructorMembers + 1] = e
@           end
@       end
@
@   elseif c.type == "list" then
@       class = cap(c.name)
@       elements = { c.member }
@   elseif c.type == "alternative" then
@       class = cap(c.name)
@       elements = c.alternatives
@   end
@   if class then


/**
 * Constructor for @(luaConfigPath)
 */
@(classPath)@(cap(c.name))()
@       if #constructorMembers > 0 then
    :
@           for i, m in ipairs(constructorMembers) do
@               local comma = (i == #constructorMembers) and "" or ","
@               local defaultValue = defaultValues and defaultValues[m.name]
@               if defaultValue ~= nil and m.default ~= nil then
@                   error("doubled default values: in config.lua and in ConfigDefinition.lua for "..luaConfigPath.."/"..m.name)
@               end
@               if m.default == nil and defaultValue ~= nil then m.default = defaultValue end
@               if defaultValue == nil then defaultValue = m.default end
@               if m.type == "map" or m.type == "list" or m.type == "alternative" then
@                       local eClass = cap(m.name)
                    @(m.name)(OwningPtr<@(eClass)>(new @(eClass)()))@(comma)
@               elseif defaultValue ~= nil then
@                   if m.type == "String" then
                    @(m.name)("@(string.gsub(defaultValue, '"', '\\"'))")@(comma)
@                   else
                    @(m.name)(@(tostring(defaultValue)))@(comma)
@                   end
@               elseif m.type == "String" then
                    @(m.name)()@(comma)
@               else
@                   error("No default value for "..luaConfigPath.."/"..m.name)
@                   if m.type == "bool" then
                    @(m.name)(false)@(comma)
@                   elseif m.type == "int" or m.type == "long" then
                    @(m.name)(0)@(comma)
@                   end
@               end
@           end
@       end
{}

/**
 *
 */
void @(classPath)readConfig(LuaVar luaData)
{
    if (luaData.isValid())
    {
        if (!luaData.isTable()) {
            throw ConfigException(String() << "Error: @(luaConfigPath) must be table, but is "
                                           << luaData.getTypeName());
        }
@   local luaVarDecl = "LuaVar "
@   if c.type == "map" then
@       assert(c.entries and #c.entries > 0, "no entries in map '"..(c.name or "???").."'")
@       for _, e in ipairs(c.entries) do
@           if e.type == "map" or e.type == "list" or e.type == "alternative" then
        this->@(e.name)->readConfig(luaData["@(e.name)"]);
@           else
        @(luaVarDecl)luaVar = luaData["@(e.name)"];
@               if #luaVarDecl > 0 then
@                   luaVarDecl = ""
@               end
        if (luaVar.isValid()) {
            this->@(e.name) = luaVar.@(converterMethods[e.type])();
@               if not e.default then            
        } else {
            throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@               end
        }
@           end
@       end
@   elseif c.type == "list" then
@       local e = c.member
        this->@(c.name).clear();
        LuaAccess luaAccess = luaData.getLuaAccess();
        LuaVar luaVar(luaAccess);
        for (int i = 0; luaVar = luaData[i + 1], luaVar.isValid(); ++i)
        {
@           if e.type == "map" or e.type == "list" or e.type == "alternative" then
            OwningPtr<@(cap(e.name))> ptr(new @(cap(e.name))());
            ptr->readConfig(luaVar);
            this->@(c.name).append(ptr);
@           else
            if (luaVar.isValid()) {
                this->@(c.name).append(luaVar.@(converterMethods[e.type])());
@               if not e.default then            
            } else {
                throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@               end
            }
@           end
        }
@   elseif c.type == "alternative" then
@       assert(c.alternatives and #c.alternatives > 0, "no entries in alternatives '"..(c.name or "???").."'")
@       for _, a in ipairs(c.alternatives) do
        this->@(a.name).invalidate();
@       end
        do
        {
@       for i, a in ipairs(c.alternatives) do
@           assert(a.type == "map", "alternative "..a.name.." must be of type 'map'")
@           local firstEntry = assert(a.entries[1], "alternative "..a.name.." must have entries")
            if (luaData["@(firstEntry.name)"].isValid())
            {
                this->@(a.name) = OwningPtr<@(cap(a.name))>(new @(cap(a.name))());
                this->@(a.name)->readConfig(luaData);
                break;
            }
@       end
        } while (false);
@   end
    }
    else
    {
    
    }
}
@
@       if c.type == "map" then
@           for _, e in ipairs(c.entries) do
@               classMethods(e, classPath..cap(e.name).."::", 
@                            defaultValues and defaultValues[e.name], defaultIndex, path(luaConfigPath, e.name))
@           end
@       elseif c.type == "list" then
@           local nextIndex
@           if c.index then
@               nextIndex = {}
@               local idField = c.index
@               assert(defaultValues, "default config values are needed for "..luaConfigPath)
@               for i, v in ipairs(defaultValues) do
@                   local id = v[idField]
@                   if id and not nextIndex[id] then
@                       nextIndex[id] = v
@                   end
@               end
@           end
@           local m = c.member
@           classMethods(m, classPath..cap(m.name).."::", 
@                        nil, nextIndex, luaConfigPath)
@       elseif c.type == "alternative" then
@           for _, a in ipairs(c.alternatives) do
@               classMethods(a, classPath..cap(a.name).."::", 
@                            defaultValues, defaultIndex, luaConfigPath)
@           end
@       end
@   end
@ end
@
@
@ classMethods(configDef, "ConfigData::", defaultConfig, nil, "")
