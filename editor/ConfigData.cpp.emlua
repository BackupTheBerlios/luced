/////////////////////////////////////////////////////////////////////////////////////
//
//   LucED - The Lucid Editor
//
//   Copyright (C) 2005-2010 Oliver Schmidt, oliver at luced dot de
//
//   This program is free software; you can redistribute it and/or modify it
//   under the terms of the GNU General Public License Version 2 as published
//   by the Free Software Foundation in June 1991.
//
//   This program is distributed in the hope that it will be useful, but WITHOUT
//   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
//   more details.
//
//   You should have received a copy of the GNU General Public License along with 
//   this program; if not, write to the Free Software Foundation, Inc., 
//   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//
/////////////////////////////////////////////////////////////////////////////////////

#include "ConfigData.hpp"
#include "LuaIterator.hpp"
#include "ConfigException.hpp"

using namespace LucED;

@ local functions  = require("functions")
@ local cap        = functions.capitalize
@
@ local configDef  = require("ConfigDefinition")
@ 
@
@ local converterMethods =
@ {
@   ["bool"]   = "toBoolean",
@   ["String"] = "toString",
@   ["int"]    = "toInt",
@   ["long"]   = "toLong",
@   ["double"] = "toNumber",
@ }
@
@ local function getDefaultValue(e)
@   assert(e.default, "default entry for "..e.name)
@   if e.type == "String" then
@       return '"'..string.gsub(e.default, '["\\]', [[\%0]])..'"'
@   else
@       return e.default
@   end
@ end
@
@ local function path(p1, p2)
@   return (#p1 > 0 and #p2 > 0 and p2:sub(1,1) ~= "[" and p1.."/"..p2) or (p1..p2)
@ end

void ConfigData::readConfig(LuaVar luaData0)
{
        LuaAccess luaAccess = luaData0.getLuaAccess();
@ local function elementCode(c, classPath, luaConfigPath, counter)
@   if c.type == "map" then
@       assert(c.entries and #c.entries > 0, "no entries in map '"..(c.name or "???").."'")
@       for _, e in ipairs(c.entries) do
@           if e.type == "map" or e.type == "list" then
@               local class = classPath..cap(e.name)
        {
            LuaVar luaData@(counter) = luaData@(counter - 1)["@(e.name)"];
            //ptr@(counter - 1)->@(e.name) = OwningPtr<@(class)>(new @(class)());
            RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(e.name);
@           emluaAddIndent(4)
@           elementCode(e, class.."::", path(luaConfigPath, e.name), counter + 1)
@           emluaAddIndent(-4)
        }
@           else
        {
            LuaVar luaData@(counter) = luaData@(counter - 1)["@(e.name)"];
            if (luaData@(counter).isValid()) {
                ptr@(counter - 1)->@(e.name) = luaData@(counter).@(converterMethods[e.type])();
@           if not e.default then            
            } else {
                throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@           end
            }
        }
@           end
@       end
@   elseif c.type == "list" then
        if (luaData@(counter -1).isValid())
        {
            if (!luaData@(counter -1).isTable()) {
                throw ConfigException(String() << "Error: @(luaConfigPath) must be table, but is "
                                               << luaData@(counter -1).getTypeName());
            }
            for (LuaIterator i@(counter)(luaAccess, 0); 
                             i@(counter).in(luaData@(counter -1)); 
                             ++i@(counter))
@       local e = c.member
@       if e.type == "map" or e.type == "list" or e.type == "alternative" then
@           local class = classPath..cap(e.name)                         
            {
                LuaVar luaData@(counter) = i@(counter).value();
                ptr@(counter - 1)->@(c.name).append(OwningPtr<@(class)>(new @(class)()));
                RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(c.name)[i@(counter)];
@           emluaAddIndent(2*4)
@           elementCode(e, class.."::", 
@                          path(luaConfigPath,    (c.type ~= "list" and e.name) 
@                                              or ('[" << (i'..counter..' + 1) << "]')), 
@                          counter + 1)
@           emluaAddIndent(-2*4)
            }
@       else
            {
                LuaVar luaData@(counter) = i@(counter).value();
                if (luaData@(counter).isValid()) {
                    ptr@(counter - 1)->@(c.name).append(luaData@(counter).@(converterMethods[e.type])());
@           if not e.default then            
                } else {
                    throw ConfigException(String() << "Error: @(luaConfigPath) missing value for @(e.name)");
@           end
                }
            }
@       end
        }
@   elseif c.type == "alternative" then
        if (luaData@(counter -1).isValid())
        {
            if (!luaData@(counter -1).isTable()) {
                throw ConfigException(String() << "Error: @(luaConfigPath) must be table, but is "
                                               << luaData@(counter -1).getTypeName());
            }
@       assert(c.alternatives and #c.alternatives > 0, "no entries in alternatives '"..(c.name or "???").."'")
            do
            {
                LuaVar luaData@(counter)(luaAccess);
@       for i, a in ipairs(c.alternatives) do
@           assert(a.type == "map", "alternative "..a.name.." must be of type 'map'")
@           local firstEntry = assert(a.entries[1], "alternative "..a.name.." must have entries")
                luaData@(counter) = luaData@(counter - 1)["@(firstEntry.name)"];
                if (luaData@(counter).isValid())
                {
@           local class = classPath..cap(a.name)
                    luaData@(counter) = luaData@(counter - 1);
                    ptr@(counter - 1)->@(a.name) = OwningPtr<@(class)>(new @(class)());
                    RawPtr<@(class)> ptr@(counter) = ptr@(counter - 1)->@(a.name);
@               emluaAddIndent(3*4)
@               elementCode(a, class.."::", path(luaConfigPath, a.name), counter + 1)
@               emluaAddIndent(-3*4)
                    break;
                }
@       end
            } while (false);
        }
@   end
@ end
        RawPtr<ConfigData> ptr0 = this;
@ elementCode(configDef, "", "", 1)
}
@
@
@
@
@ local function classConstructors(c, classPath, luaConfigPath)
@   local constructorMembers = {} 
@   local elements = {}
@   local class
@   if c.type == "map" then
@       class = cap(c.name)
@       elements = c.entries
@
@       for i, e in ipairs(c.entries) do
@           if    e.type == "bool" 
@              or e.type == "int" 
@              or e.type == "long" 
@              or e.type == "map" 
@              or e.type == "list" 
@              or e.type == "alternative" 
@              or e.default 
@           then
@               constructorMembers[#constructorMembers + 1] = e
@           end
@       end
@
@   elseif c.type == "list" then
@       class = cap(c.name)
@       elements = { c.member }
@   elseif c.type == "alternative" then
@       class = cap(c.name)
@       elements = c.alternatives
@   end
@   if class then


/**
 * Constructor for @(luaConfigPath)
 */
@(classPath)@(cap(c.name))()
@       if #constructorMembers > 0 then
    :
@           for i, m in ipairs(constructorMembers) do
@               local comma = (i == #constructorMembers) and "" or ","
@               if m.default then
@                   if m.type == "String" then
                    @(m.name)("@(string.gsub(m.default, '"', '\\"'))")@(comma)
@                   else
                    @(m.name)(@(m.default))@(comma)
@                   end
@               elseif m.type == "map" or m.type == "list" or m.type == "alternative" then
@                       local eClass = cap(m.name)
                    @(m.name)(OwningPtr<@(eClass)>(new @(eClass)()))@(comma)
@               else
@                   if m.type == "bool" then
                    @(m.name)(false)@(comma)
@                   elseif m.type == "int" or m.type == "long" then
                    @(m.name)(0)@(comma)
@                   end
@               end
@           end
@       end
{}
@       for _, e in ipairs(elements) do
@           classConstructors(e, classPath..cap(e.name).."::", path(luaConfigPath, e.name))
@       end
@   end
@ end
@
@
@ classConstructors(configDef, "ConfigData::", "")
